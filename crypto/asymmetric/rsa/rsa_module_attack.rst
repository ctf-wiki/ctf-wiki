..

模数
====

暴力分解 N
^^^^^^^^^^^^^^^

攻击条件
--------

在 N 的比特位数小于 512 的时候，可以采用大整数分解的策略获取 p 和 q。

例子
----

这里我们以JarvisOJ - Medium RSA为例进行介绍，题目如下

    还记得 veryeasy RSA 吗？是不是不难？那继续来看看这题吧，这题也不难。
    已知一段 RSA 加密的信息为：0xdc2eeeb2782c 且已知加密所用的公钥：
    (N=322831561921859 e = 23) 请解密出明文，提交时请将数字转化为 ascii
    码提交 比如你解出的明文是 0x6162，那么请提交字符串 ab 提交格式:
    PCTF{明文字符串}

可以看出，我们的N比较小，这里我们直接使用factordb进行分解，可以得到

322831561921859 = 13574881 * 23781539

进而我们简单编写程序如下

.. code:: python

    import gmpy2
    p = 13574881
    q = 23781539
    n = p * q
    e = 23
    c = 0xdc2eeeb2782c
    phin = (p - 1) * (q - 1)
    d = gmpy2.invert(e, phin)
    p = gmpy2.powmod(c, d, n)
    tmp = hex(p)
    print tmp, tmp[2:].decode('hex')

结果如下

.. code:: shell

    ➜  Jarvis OJ-Basic-easyRSA git:(master) ✗ python exp.py
    0x33613559 3a5Y

p&q不当分解N
^^^^^^^^^^^^^^^

攻击条件
--------

当RSA中p和q选取不当时，我们也可以进行攻击。

|p-q|很大
~~~~~~~~~~~

当p-q很大时，一定存在某一个参数较小，这里我们假设为p，那么我们可以通过穷举的方法对模数进行试除，从而分解模数，得到保密参数与明文信息。基本来说，不怎么可行。

|p-q|较小
~~~~~~~~~~~

首先

:math:`\frac{(p+q)^2}{4}-n=\frac{(p+q)^2}{4}-pq=\frac{(p-q)^2}{4}`

既然|p-q|较小，那么\ :math:`\frac{(p-q)^2}{4}`
自然也比较小，进而\ :math:`\frac{(p+q)^2}{4}`
只是比n稍微大一点，所以\ :math:`\frac{p+q}{2}` 与 :math:`\sqrt{n}`
相近。那么我们可以按照如下方法来分解

-  顺序检查 :math:`\sqrt{n}`
   的每一个整数x，直到找到一个x使得 :math:`x^2-n`
   是平方数，记为 :math:`y^2` 。
-  那么 :math:`x^2-n=y^2` ，进而根据平方差公式即可分解n。

模不互素
^^^^^^^^^^^^^^^

攻击原理
--------

当存在两个公钥的N不互素时，我们显然可以直接对这两个数求最大公因数，然后直接获得p，q。进而获得相应的私钥。

例子
----

这里我们以SCTF
rsa2为例进行介绍。直接打开pcap包，发现有一堆的消息，包含N和e，然后试了试不同的N是否互素，我试了前两个

.. code:: python

    import gmpy2
    n1 = 20823369114556260762913588844471869725762985812215987993867783630051420241057912385055482788016327978468318067078233844052599750813155644341123314882762057524098732961382833215291266591824632392867716174967906544356144072051132659339140155889569810885013851467056048003672165059640408394953573072431523556848077958005971533618912219793914524077919058591586451716113637770245067687598931071827344740936982776112986104051191922613616045102859044234789636058568396611030966639561922036712001911238552391625658741659644888069244729729297927279384318252191421446283531524990762609975988147922688946591302181753813360518031
    n2 = 19083821613736429958432024980074405375408953269276839696319265596855426189256865650651460460079819368923576109723079906759410116999053050999183058013281152153221170931725172009360565530214701693693990313074253430870625982998637645030077199119183041314493288940590060575521928665131467548955951797198132001987298869492894105525970519287000775477095816742582753228905458466705932162641076343490086247969277673809512472546919489077884464190676638450684714880196854445469562733561723325588433285405495368807600668761929378526978417102735864613562148766250350460118131749533517869691858933617013731291337496943174343464943
    print gmpy2.gcd(n1, n2)

结果发现竟然不互素，，

.. code:: shell

    ➜  scaf-rsa2 git:(master) ✗ python exp.py
    122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137

那么我们就可以直接来解密了，这里我们利用第一对公钥密码。代码如下

.. code:: python

    from Crypto.PublicKey import RSA
    from Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEP
    import gmpy2
    from base64 import b64decode
    n1 = 20823369114556260762913588844471869725762985812215987993867783630051420241057912385055482788016327978468318067078233844052599750813155644341123314882762057524098732961382833215291266591824632392867716174967906544356144072051132659339140155889569810885013851467056048003672165059640408394953573072431523556848077958005971533618912219793914524077919058591586451716113637770245067687598931071827344740936982776112986104051191922613616045102859044234789636058568396611030966639561922036712001911238552391625658741659644888069244729729297927279384318252191421446283531524990762609975988147922688946591302181753813360518031
    n2 = 19083821613736429958432024980074405375408953269276839696319265596855426189256865650651460460079819368923576109723079906759410116999053050999183058013281152153221170931725172009360565530214701693693990313074253430870625982998637645030077199119183041314493288940590060575521928665131467548955951797198132001987298869492894105525970519287000775477095816742582753228905458466705932162641076343490086247969277673809512472546919489077884464190676638450684714880196854445469562733561723325588433285405495368807600668761929378526978417102735864613562148766250350460118131749533517869691858933617013731291337496943174343464943
    p1 = gmpy2.gcd(n1, n2)
    q1 = n1 / p1
    e = 65537
    phin = (p1 - 1) * (q1 - 1)
    d = gmpy2.invert(e, phin)
    cipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7
    plain = gmpy2.powmod(cipher, d, n1)
    plain = hex(plain)[2:]
    if len(plain) % 2 != 0:
        plain = '0' + plain
    print plain.decode('hex')

最后解密如下

.. code:: shell

    ➜  scaf-rsa2 git:(master) ✗ python exp.py       
    sH1R3_PRlME_1N_rsA_iS_4ulnEra5le

解压压缩包即可。

共模攻击
^^^^^^^^^^^^^^^

攻击条件
--------

当两个用户使用相同的模数
:math:`N` 、不同的私钥时，加密同一明文消息时即存在共模攻击。

攻击原理
--------

设两个用户的公钥分别为 :math:`e_1` 和
:math:`e_2` ，且两者互质。明文消息为 :math:`m` ，密文分别为：

.. math::

   c_1 = m^{e_1}\bmod N \\ c_2 = m^{e_2}\bmod N

当攻击者截获 :math:`c_1` 和 :math:`c_2`
后，就可以恢复出明文。用扩展欧几里得算法求出
:math:`re_1+se_2=1 \bmod n` 的两个整数 :math:`r` 和
:math:`s` ，由此可得：

.. math::

   \begin{align}
   c_{1}^{r}c_{2}^{s} &\equiv m^{re_1}m^{se_2}\bmod n\\
   &\equiv m^{(re_1+se_2)} \bmod n\\
   &\equiv m\bmod n
   \end{align}

例子
----

题目描述：

::

    {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,773}

    {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,839}

    message1=3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349

    message2=5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535

    题目来源：XMan 一期夏令营课堂练习

可以看出两个公钥的n是一样的，并且两者的e互素。写一个脚本跑一下：

.. code:: python

    import gmpy2
    n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249
    e1 = 773

    e2 = 839

    message1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349

    message2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535
    # s & t
    gcd, s, t = gmpy2.gcdext(e1, e2)
    if s < 0:
        s = -s
        message1 = gmpy2.invert(message1, n)
    if t < 0:
        t = -t
        message2 = gmpy2.invert(message2, n)
    plain = gmpy2.powmod(message1, s, n) * gmpy2.powmod(message2, t, n) % n
    print plain

得到

.. code:: shell

    ➜  Xman-1-class-exercise git:(master) ✗ python exp.py
    1021089710312311910410111011910111610410511010710511610511511211111511510598108101125

这时候需要考虑当时明文是如何转化为这个数字了，一般来说是16转换，ascii字符转换，或者base64解密。这个应该是ascii字符转换，进而我们使用如下代码得到flag

.. code:: python

    i = 0
    flag = ""
    plain = str(plain)
    while i < len(plain):
        if plain[i] == '1':
            flag += chr(int(plain[i:i + 3]))
            i += 3
        else:
            flag += chr(int(plain[i:i + 2]))
            i += 2
    print flag

这里之所以使用1来判断是否为三位长度，是因为flag一般都是明文字符，而1开头的长度为1或者2的数字，一般都是不可见字符。

flag

.. code:: shell

    ➜  Xman-1-class-exercise git:(master) ✗ python exp.py
    flag{whenwethinkitispossible}

题目
----

-  Jarvis OJ very hard RSA
